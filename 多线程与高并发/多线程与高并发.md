笔记较少，需要配合代码复习：[例子汇总](https://github.com/2994413619/some_demo/tree/main/src/com/ityc/se/juc/v1)

# 一、基础

## 1、零散记录

- 同步和非同步方法可以同时调用。
- atomic lock都是自旋锁
- sleep()：指定时间不使用cpu
- yield()：让出一个cpu时间片
- join()：如果有两个线程t1、t2；t1执行了t2.join()，则暂停t1执行，等待t2执行完再继续执行t1。（经常用来等待另一个线程的介绍，自己调用自己的join方法没什么用）
- stop()：不建议使用，容易产生状态不一致。
- wait()——notify()、notifyAll()
- interrupter()
- lockSupport.park()——LockSupport.unpark()
- getState()：获得线程状态

## 2、synchronized

- synchronized即保证了可见性，也保证了原子性。

- synchronized——Hotspot实现：对象头拿出2位来标志
- synchronized(this)和synchronized方法是等价的，synchronized static方法相当于synchronized(T.class)；T.class也是一个对象（特殊的对象）。
- 写加锁，读不加锁。有可能出现脏读的问题。
- synchronized的可重入性：一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。（子类重写父类synchronizd方法，子类调用super...如果不是可重入就会产生死锁）
- 程序中出现异常，锁会被释放。
- synchronized不能用String常量（不同地方使用相同字符串是同一个对象）、Integer（变一下值会变成新的对象）、Long等基础类型
- 锁对象改变：锁定某对象o，如果o的属性发生改变，不影响锁的使用；但是如果o变成另外一个对象，则锁定的对象发生改变；应该避免将锁定对象的引用变成另外的对象。（习惯给锁对象加 final修饰）

## 3、synchronized的底层实现

JDK早期：重量级 - OS

之后改进：

### （1）锁升级

（1）偏向锁（markword 记录这个线程ID）

（2）如果有其他线程争用，升级为自旋锁

（3）默认争抢10次以后，重量级锁 - OS

自旋锁占CPU，但是不访问操作系统，在用户态解决所得问题，不经过内核态，所以效率更高。



**问题**：什么时候用自旋？什么时候用系统锁？

- 执行时间短（加锁代码），线程数少，用自旋
- 执行时间长，线程数多，用系统锁

### （2）synchronized优化

- 锁粒度细化
- 某些情况下也可以进行锁粒度粗化（细锁多，减少锁竞争）

## 4、volatile

- 保证线程可见性
  - MESI 缓存一致性协议
- 禁止指令重排（volatile禁止的是语言级别的，不能禁止CPU）
  - 指令
    - loadfence指令
    - storefence指令
  - DCL单例（double check lock）
  - new对象三步（指令重排可能导致第二第三步顺序颠倒）
    - 分配内存
    - 赋初值
    - 变量指向内存地址
- 不保证原子性

问：**到底是强制读主线程的，还是写入时间不定**

## 5、CAS

- 也叫：无锁优化、自旋、乐观锁

- Compare And Swap

- CPU源语支持

- Atomic开头的类都是CAS的

- cas(V, Expected, NewValue)：中间不能被打断，CPU源语支持

  if V == E

  V = New

  otherwise try again or fail

**ABA问题**：原来值是1，一个线程get后，在进行cas操作前，这个1变成了2，又变成了1。

解决方法：利用版本号解决。

atomic中的类：AtomicStampedReference

**Unsafe**

单例；Compare And Set操作都是在Unsafe类中完成。

- 直接操作内存：allocateMemory 
- 直接生成实例
- 直接操作类或实例变量

# 二、JUC同步工具

## 1、atomic

AtomicLong：CAS锁

LongAdder：分段锁 + CAS；专门用来做多个线程对一个数进行递增。

问题：多个线程对一个数进行递增，那种效率更高？synchronized、AtomicLong、LongAdder

## 2、ReentrantLock

- 可以替代synchronized，使用lock()、unlock()。
- 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放；
- lock.tryLock(5, TimeUnit.SECONDS)尝试5秒内获得锁，获得不了就结束阻塞
- lock.lockInterruptibly()使用该方法表示可以被打断
- new ReentrantLock(true)创建公平锁
- 公平的实现是使用一个队列来实现的，这个队列在AbstractQueuedSynchronizer类中
- 多个condition本质就是多个等待队列，可以notifyAll()指定的线程组


## 3、CountDownLatch门闩

用于某个线程在其他线程之后执行

例子：100个线程执行完后，主线程继续执行

```java
private static void usingCountDownLatch() {
    Thread[] threads = new Thread[100];
    CountDownLatch latch = new CountDownLatch(threads.length);

    for(int i=0; i<threads.length; i++) {
        threads[i] = new Thread(()->{
            int result = 0;
            for(int j=0; j<10000; j++) result += j;
            latch.countDown();
        });
    }

    for (int i = 0; i < threads.length; i++) {
        threads[i].start();
    }

    try {
        latch.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("end latch");
}
```

## 4、CyclicBarrier线程栅栏

20个线程阻塞，然后一起执行。

```java
public static void main(String[] args) {

    //CyclicBarrier barrier = new CyclicBarrier(20);

    /*CyclicBarrier barrier = new CyclicBarrier(20, new Runnable() {
            @Override
            public void run() {
                System.out.println("满人，发车");
            }
        });*/

    CyclicBarrier barrier = new CyclicBarrier(20, () -> {
        System.out.println("满人，发车");
    });

    for(int i = 0; i < 100; i++) {
        new Thread(()->{
            try {
                System.out.println("等待");
                barrier.await();
                System.out.println("执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }


}
```

限流工具：Guava RateLimiter

## 5、Phaser

有可能用到的场景：遗传算法

## 6、ReadWriteLock

- 共享锁
- 排他锁（互斥锁）

```java
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
Lock readLock = readWriteLock.readLock();
Lock writeLock = readWriteLock.writeLock();
```

## 7、Semaphore信号量

同时执行线程的数量，限流

```java
Semaphore s = new Semaphore(2, true);//可以设置为公平
s.acquire();//获得许可，信号减一;没获取到，则阻塞在这,等待其他线程release
s.release();//释放许可
```

## 8、Exchanger

两个线程间交换对象，交换方法是阻塞的

ReadWriteLock——stampedLock

## 9、LockSupport

unpark可以先park执行

```java
LockSupport.park();//当前线程阻塞
LockSupport.unpark(t);//t线程开始运行，停止阻塞
```

# 三、源码：

**读源码原则**：

- 跑步起来不读

- 解决问题就好——目的性

- 一条线索到底

- 无关细节略过

## 1、AQS：

- Template method

- Callback Function

- 父类默认实现

- 子类具体实现


### （1）ReentrantLock源码：

**jdk 11如下**

类继承关系图：NonfairSync ——> Sync ——> AQS（class名:AbstractQueuedSynchronizer）

<img src="img\ReetrantLock_2.png" />

方法调用图：Template method：AQS.acquiree(1)调用了tryAcquire(1)，AQS自己有改方法，但是实际运行中调用的是子类的tryAcquire(1)，子类重写该方法

<img src="img\ReentrantLock_1.png" />





### （2）AQS源码（CLH）

核心：state（volatile int）；该值的意义取决于子类；在ReentrantLock表示0表示未加锁，1表示加了锁，2表示重入了两次。在CountDownLatch中表示。。。

AQS里面维护了一个队列(元素就是node)，有一个内部类Node，node有一个属性是Thread，有前一个节点引用，和后一个节点引用，双向链表（需要看前一个节点的状态）。

<img src="img\AQS_1.png" />



VarHandle  1.9之后才有，通过varhandle可以做cas的原子操作。没有varhandle之前，只能用反射，varhandle效率更高。

- 普通属性原子操作
- 比反射快，直接操作二进制码

## 2、ThreadLocal源码

Thread对象中维护了一个Map，key就是ThreadLocal。

Spring中的声明式事务用了ThreadLocal

ThreadLocal的set()方法：

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    //获得的是Thread中的map;map(ThreadLocal, value)
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value);
    } else {
        createMap(t, value);
    }
}
```



## 3、强软弱虚引用

- 强：new出来的对象
- 软：堆内存不够，会回收软引用指向的对象
  - 大对象的缓存
  - 常用对象的缓存
- 弱：遭到gc就会回收
  - 缓存，没有容器引用指向的时候就需要清除的缓存
  - ThreadLocal（不使用一定要remove(),不然会内存泄露；弱引用只能解决key,不能解决value）
  - WeakHashMap
- 虚（给写JVM的人用的，或自己写netty）
  - 管理堆外内存
  - JVM回收不到对外堆存，可以用虚引用检测DirectByteBuffer，它被回收的时候，我们通过Queue检测，然后回收堆外内存（java回收堆外内存，Unsafe）

弱引用：

<img src="img\weeakReference.png" />

虚引用：

<img src="img\phantomReference.png" />

# 四、同步容器

## 1、容器Tree

- Collection
  - List
    - CopyOnWriteList
    - Vector      Stack
    - ArrayList
    - LinkedList
  - Set
    - HashSet      LinkedHashMap
    - SortedSet     TreeSet
    - EnumSet
    - CopyOnWriteArraySet
    - ConcurrentSkipListSet
  - Queue
    - Deque
      - ArrayDeque
      - BlokingDeque      LinkedBlockingDeque
    - BlockingQueue
      - ArrayBlockingQueue
      - PriorityBlockingQueue
      - LinkedBlockingQueue
      - TransferQueue         LinkedTransferQueue
      - SynchronousQueue
    - PriorityQueue
    - ConcurrentLinkedQueue
    - DelayQueue
- Map
  - HashMap	LinkedHashMap
  - TreeMap
  - WeakHashMap
  - IdentityHashMap
  - ConcurrentHashMap
  - ConcurrentSkipListMap

## 2、历史

Queue与List主要区别，它是为高并发设计的

Queue的子接口——Deque（双端队列，两端都可以取和放）

1.0的时候只有两个集合：Vector，HashTable；自带锁，基本不用。

```java
//可以把hashMap变成线程安全的；里面new Object()，然后synchronized这个对象
Collections.synchronizedMap(new HashMap<UUID, UUID>());
```

ConcurrentHashMap主要是读的效率更高，写的效率比HashTable低。





> 同步容器类
>
> 1：Vector Hashtable ：早期使用synchronized实现 
>
> 2：ArrayList HashSet ：未考虑多线程安全（未实现同步）
>
> 3：HashSet vs Hashtable StringBuilder vs StringBuffer
>
> 4：Collections.synchronized***工厂方法使用的也是synchronized
>
> 使用早期的同步容器以及Collections.synchronized***方法的不足之处，请阅读：
> http://blog.csdn.net/itm_hadf/article/details/7506529
>
> 使用新的并发容器
> http://xuganggogo.iteye.com/blog/321630



## 3、Map

非同步容器：

- LinkedHashMap遍历效率比HashMap高
- TreeMap：红黑树，排好序的
- HashMap：无序



高并发集合：

- ConcurrentHashMap：无序
- ConcurrentSkipListMap：有序；跳表结构；CAS实现在Tree的节点上太复杂了，所有没有CurrentTreeMap，但是有时候又需要排好序的Map，所有有了这个集合。

[跳表和ConcurrentSkipListMap源码](http://blog.csdn.net/sunxianghuang/article/details/52221913)

## 4、List

CopyOnWriteSet

CopyOnWriteList：写时复制；读不加锁，写的时候，synchronized加锁，并把原来的数组复制一份，操作复制的新数组，然后再替换掉原来的数组。使用情况：读特别多，写比较少。

add源码：

```java
public boolean add(E e) {
    synchronized (lock) {
        Object[] es = getArray();
        int len = es.length;
        es = Arrays.copyOf(es, len + 1);
        es[len] = e;
        setArray(es);
        return true;
    }
}
```

synchronizedList：

```java
List<String> strs = new ArrayList<>();
List<String> strsSync = Collections.synchronizedList(strs);
```



## 5、Queue

Queue方法：

```java
strs.offer(obj);//添加元素
strs.poll();//取出并remove
strs.peek();//取出不remove
```

非BlockingQueue：ConcurrentLinkedQueue

### （1）BlockingQueue

BlockingQueue添加的方法：

```java
//阻塞的存取方法
strs.take();//当队列为null，阻塞
strs.put(obj); //满了就会等待，程序阻塞

//各种添加对比
strs.add(obj);//满了add会抛异常
strs.offer(obj);//满了，会返回false表示添加失败
strs.offer(obj, 1, TimeUnit.SECONDS);//阻塞一秒后失败

```



- LinkedBlockingQueue：无界队列（最大Integer.MAXVALUE）
- ArrayBlockingQueue：有界队列
- DelayQueue：按时间（可自己实现compareTo()）进行任务调度，里面的任务必须实现Delayed接口；本质是PriorityQueque
- PriorityQueque：实现是一个二叉树（小顶堆）
- SynchronousQueue：线程间传单个任务；容量为0；一个线程put()，另一个线程take()。两个均为阻塞方法，也就是说如果没有线程take()，那么put()会一致阻塞，反之亦然。自己实现线程池常用。
- TransferQueue：线程间传过个任务；加入队列后，阻塞，等到被取出后才继续往下执行；自己实现线程池常用



PipedStream：效率低



# 五、线程池

<img src="img\threadPool_1.png" />

常用类：

- Callable：又返回结果的线程接口
- Future：存储执行的将来产生的结果
- FutureTask：实现了Runnable、Future接口，成员变量还有Callable



CompletableFuture：可管理多个Future返回的结果，底层使用的ForkJoinPool。



JDK提供两种类型的线程池

- ThreadPoolExecutor
- ForkJoinPool
  - 分解汇总的任务
  - 用很少的线程可以执行很多的任务（子任务）TPE做不到先执行任务
  - CPU密集型

线程池里面维和了两个集合，一个是线程集合，一个是任务集合

<img src="img\threadPool_2.png" />



new ThreadPoolExecutor的七个参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    ...
}
```

keepAliveTime：线程多长时间没活干，超过这个时间归还线程资源给OS

threadFactory：ThreadFactory接口只有一个newThread()方法。传参可以为Executors.defaultThreadFactory()，默认的Factory。该类的newThread方法

拒绝策略可以自定义，JDK提供了4种



七——7    

创建线程或线程池时要指定有意义的线程名，方便错误回溯











# 六、高频面试加分项

# 七、Disruptor



# 八、面试题

**1、如何保证几个线程顺序执行**

法一：主线程中顺序执行start、join方法

```java
Thread thread1 = new Thread(new A());
thread1.start();
thread1.join();
Thread thread2 = new Thread(new B());
thread2.start();
thread2.join();
Thread thread3 = new Thread(new C());
thread3.start();
```

法二：创建一个只有一根线程的线程池，保证所有任务按照指定顺序执行

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
executorService.submit(new A());
executorService.submit(new B());
executorService.submit(new C());
executorService.shutdown();
```

**2、实现一个容器，提供两个方法，add，size；写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束。**

**3、写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用**

**4、两个线程交替打印A-Z、1-26**

