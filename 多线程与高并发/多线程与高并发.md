# 一、基础

## 1、零散记录

- 同步和非同步方法可以同时调用。
- atomic lock都是自旋锁
- sleep()：指定时间不使用cpu
- yield()：让出一个cpu时间片
- join()：如果有两个线程t1、t2；t1执行了t2.join()，则暂停t1执行，等待t2执行完再继续执行t1。（经常用来等待另一个线程的介绍，自己调用自己的join方法没什么用）
- stop()：不建议使用，容易产生状态不一致。
- wait()——notify()、notifyAll()
- interrupter()
- lockSupport.park()——LockSupport.unpark()
- getState()：获得线程状态

## 2、synchronized

- synchronized即保证了可见性，也保证了原子性。

- synchronized——Hotspot实现：对象头拿出2位来标志
- synchronized(this)和synchronized方法是等价的，synchronized static方法相当于synchronized(T.class)；T.class也是一个对象（特殊的对象）。
- 写加锁，读不加锁。有可能出现脏读的问题。
- synchronized的可重入性：一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。（子类重写父类synchronizd方法，子类调用super...如果不是可重入就会产生死锁）
- 程序中出现异常，锁会被释放。
- synchronized不能用String常量（不同地方使用相同字符串是同一个对象）、Integer（变一下值会变成新的对象）、Long等基础类型
- 锁对象改变：锁定某对象o，如果o的属性发生改变，不影响锁的使用；但是如果o变成另外一个对象，则锁定的对象发生改变；应该避免将锁定对象的引用变成另外的对象。（习惯给锁对象加 final修饰）

## 3、synchronized的底层实现

JDK早期：重量级 - OS

之后改进：

### （1）锁升级

（1）偏向锁（markword 记录这个线程ID）

（2）如果有其他线程争用，升级为自旋锁

（3）默认争抢10次以后，重量级锁 - OS

自旋锁占CPU，但是不访问操作系统，在用户态解决所得问题，不经过内核态，所以效率更高。



**问题**：什么时候用自旋？什么时候用系统锁？

- 执行时间短（加锁代码），线程数少，用自旋
- 执行时间长，线程数多，用系统锁

### （2）synchronized优化

- 锁粒度细化
- 某些情况下也可以进行锁粒度粗化（细锁多，减少锁竞争）

## 4、volatile

- 保证线程可见性
  - MESI 缓存一致性协议
- 禁止指令重排（volatile禁止的是语言级别的，不能禁止CPU）
  - 指令
    - loadfence指令
    - storefence指令
  - DCL单例（double check lock）
  - new对象三步（指令重排可能导致第二第三步顺序颠倒）
    - 分配内存
    - 赋初值
    - 变量指向内存地址
- 不保证原子性

问：**到底是强制读主线程的，还是写入时间不定**

## 5、CAS

- 也叫：无锁优化、自旋、乐观锁

- Compare And Swap

- CPU源语支持

- Atomic开头的类都是CAS的

- cas(V, Expected, NewValue)：中间不能被打断，CPU源语支持

  if V == E

  V = New

  otherwise try again or fail

**ABA问题**：原来值是1，一个线程get后，在进行cas操作前，这个1变成了2，又变成了1。

解决方法：利用版本号解决。

atomic中的类：AtomicStampedReference

**Unsafe**

单例；Compare And Set操作都是在Unsafe类中完成。

- 直接操作内存：allocateMemory 
- 直接生成实例
- 直接操作类或实例变量

# 二、JUC同步工具

## 1、atomic

AtomicLong：CAS锁

LongAdder：分段锁 + CAS；专门用来做多个线程对一个数进行递增。

问题：多个线程对一个数进行递增，那种效率更高？synchronized、AtomicLong、LongAdder

## 2、ReentrantLock

- 可以替代synchronized，使用lock()、unlock()。
- 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放；
- lock.tryLock(5, TimeUnit.SECONDS)尝试5秒内获得锁，获得不了就结束阻塞
- lock.lockInterruptibly()使用该方法表示可以被打断
- new ReentrantLock(true)创建公平锁
- 公平的实现是使用一个队列来实现的，这个队列在AbstractQueuedSynchronizer类中
- 多个condition本质就是多个等待队列，可以notifyAll()指定的线程组


## 3、CountDownLatch门闩

用于某个线程在其他线程之后执行

例子：100个线程执行完后，主线程继续执行

```java
private static void usingCountDownLatch() {
    Thread[] threads = new Thread[100];
    CountDownLatch latch = new CountDownLatch(threads.length);

    for(int i=0; i<threads.length; i++) {
        threads[i] = new Thread(()->{
            int result = 0;
            for(int j=0; j<10000; j++) result += j;
            latch.countDown();
        });
    }

    for (int i = 0; i < threads.length; i++) {
        threads[i].start();
    }

    try {
        latch.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("end latch");
}
```

## 4、CyclicBarrier线程栅栏

20个线程阻塞，然后一起执行。

```java
public static void main(String[] args) {

    //CyclicBarrier barrier = new CyclicBarrier(20);

    /*CyclicBarrier barrier = new CyclicBarrier(20, new Runnable() {
            @Override
            public void run() {
                System.out.println("满人，发车");
            }
        });*/

    CyclicBarrier barrier = new CyclicBarrier(20, () -> {
        System.out.println("满人，发车");
    });

    for(int i = 0; i < 100; i++) {
        new Thread(()->{
            try {
                System.out.println("等待");
                barrier.await();
                System.out.println("执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }


}
```

限流工具：Guava RateLimiter

## 5、Phaser

有可能用到的场景：遗传算法

## 6、ReadWriteLock

- 共享锁
- 排他锁（互斥锁）

```java
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
Lock readLock = readWriteLock.readLock();
Lock writeLock = readWriteLock.writeLock();
```

## 7、Semaphore信号量

同时执行线程的数量，限流

```java
Semaphore s = new Semaphore(2, true);//可以设置为公平
s.acquire();//获得许可，信号减一;没获取到，则阻塞在这,等待其他线程release
s.release();//释放许可
```

## 8、Exchanger

两个线程间交换对象，交换方法是阻塞的



缺图：四——2 开头

ReadWriteLock——stampedLock

## 9、LockSupport

unpark可以先park执行

```java
LockSupport.park();//当前线程阻塞
LockSupport.unpark(t);//t线程开始运行，停止阻塞
```

# 三、源码：

**读源码原则**：

- 跑步起来不读

- 解决问题就好——目的性

- 一条线索到底

- 无关细节略过

## 1、AQS：

- Template method

- Callback Function

- 父类默认实现

- 子类具体实现


### （1）ReentrantLock源码：

**jdk 11如下**

类继承关系图：NonfairSync ——> Sync ——> AQS（class名:AbstractQueuedSynchronizer）

<img src="img\ReetrantLock_2.png" />

方法调用图：Template method：AQS.acquiree(1)调用了tryAcquire(1)，AQS自己有改方法，但是实际运行中调用的是子类的tryAcquire(1)，子类重写该方法

<img src="img\ReentrantLock_1.png" />





### （2）AQS源码（CLH）

核心：state（volatile int）；该值的意义取决于子类；在ReentrantLock表示0表示未加锁，1表示加了锁，2表示重入了两次。在CountDownLatch中表示。。。

AQS里面维护了一个队列(元素就是node)，有一个内部类Node，node有一个属性是Thread，有前一个节点引用，和后一个节点引用，双向链表（需要看前一个节点的状态）。

<img src="img\AQS_1.png" />



VarHandle  1.9之后才有，通过varhandle可以做cas的原子操作。没有varhandle之前，只能用反射，varhandle效率更高。

- 普通属性原子操作
- 比反射快，直接操作二进制码

## 2、ThreadLocal源码

Thread对象中维护了一个Map，key就是ThreadLocal。

Spring中的声明式事务用了ThreadLocal

ThreadLocal的set()方法：

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    //获得的是Thread中的map;map(ThreadLocal, value)
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value);
    } else {
        createMap(t, value);
    }
}
```



强软弱虚引用

- 强：new出来的对象
- 软：堆内存不够，会回收软引用指向的对象
  - 大对象的缓存
  - 常用对象的缓存
- 弱：遭到gc就会回收
  - 缓存，没有容器引用指向的时候就需要清除的缓存
  - ThreadLocal（不使用一定要remove(),不然会内存泄露；弱引用只能解决key,不能解决value）
  - WeakHashMap
- 虚（给写JVM的人用的，或自己写netty）
  - 管理堆外内存
  - JVM回收不到对外堆存，可以用虚引用检测DirectByteBuffer，它被回收的时候，我们通过Queue检测，然后回收堆外内存（java回收堆外内存，Unsafe）

缺图：五——10 05:06

缺图：六——1 0:0











# 四、同步容器

缺图：六——2 10:13

Queue与List主要区别，它是为高并发设计的

Queue的子接口——Deque（双端队列，两端都可以取和放）

1.0的时候只有两个集合：Vector，HashTable；自带锁，基本不用。

```java
//可以把hashMap变成线程安全的；里面new Object()，然后synchronized这个对象
Collections.synchronizedMap(new HashMap<UUID, UUID>());
```

ConcurrentHashMap主要是读的效率更高，写的效率比HashTable低。





> 同步容器类
>
> 1：Vector Hashtable ：早期使用synchronized实现 
> 2：ArrayList HashSet ：未考虑多线程安全（未实现同步）
> 3：HashSet vs Hashtable StringBuilder vs StringBuffer
> 4：Collections.synchronized***工厂方法使用的也是synchronized
>
> 使用早期的同步容器以及Collections.synchronized***方法的不足之处，请阅读：
> http://blog.csdn.net/itm_hadf/article/details/7506529
>
> 使用新的并发容器
> http://xuganggogo.iteye.com/blog/321630



六——7















# 五、线程池

# 六、高频面试加分项

# 七、Disruptor



























/* ------------------------------------------------分割线-------------------------------------------------------------------------------- */



# 七、面试题



## 1、如何保证几个线程顺序执行

法一：主线程中顺序执行start、join方法

```java
Thread thread1 = new Thread(new A());
thread1.start();
thread1.join();
Thread thread2 = new Thread(new B());
thread2.start();
thread2.join();
Thread thread3 = new Thread(new C());
thread3.start();
```

法二：创建一个只有一根线程的线程池，保证所有任务按照指定顺序执行

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
executorService.submit(new A());
executorService.submit(new B());
executorService.submit(new C());
executorService.shutdown();
```

2、实现一个容器，提供两个方法，add，size；写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束。













例子汇总：https://github.com/2994413619/some_demo/tree/main/src/com/ityc/se/juc/v1

