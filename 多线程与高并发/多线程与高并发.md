# 一、基础概念

synchronized即保证了可见性，也保证了原子性。

同步和非同步方法可以同时调用。

一：2  5:49







# 二、JUC同步工具

# 三、同步容器

# 四、线程池

# 五、高频面试加分项

# 六、Disruptor

















































/* ------------------------------------------------分割线-------------------------------------------------------------------------------- */



创建线程的两种方式：继承Thread类、实现Runable接口

相关方法：

sleep()：指定时间不使用cpu

yield()：让出一个cpu时间片

join()：如果有两个线程t1、t2；t1执行了t2.join()，则暂停t1执行，等待t2执行完再继续执行t1。（经常用来等待另一个线程的介绍，自己调用自己的join方法没什么用）

stop()：不建议使用，容易产生状态不一致。

wait()——notify()、notifyAll()

interrupter()

lockSupport.park()——LockSupport.unpark()

getState()：获得线程状态

 

面试题：

可以同时调用同步和非同步方法

如何保证几个线程顺序执行：

法一：主线程中顺序执行start、join方法

```java
Thread thread1 = new Thread(new A());
thread1.start();
thread1.join();
Thread thread2 = new Thread(new B());
thread2.start();
thread2.join();
Thread thread3 = new Thread(new C());
thread3.start();
```

法二：创建一个只有一根线程的线程池，保证所有任务按照指定顺序执行

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
executorService.submit(new A());
executorService.submit(new B());
executorService.submit(new C());
executorService.shutdown();
```

## **synchroniezd**

Object o = new Object();

synchronized(0){}

public synchronized void m() {}等价于synchronized(this){}

public synchronized static void m() {}等价于synchronized(T.class){}

 

synchronized即有可见性，也有原子性

 

synchronized是可重入锁：一个同步方法可以调用另一个同步方法，一个线程可以多次获得同一把锁。（子类重写父类synchronizd方法，子类调用super...如果不是可重入就会产生死锁）

 

发生异常，锁被释放

 

TimeUnit.SECONDS.sleep()

Thread.currentThread.getName()

 

synchronized底层实现：JVM没有要求。hotspot实现（mark word）：在一个对象（64位）头上拿出两位来判断

 

JDK早期的 重量级 - OS

后来的改进

锁升级的概念：

  我就是厕所所长 （一 二）

 

sync (Object)

markword 记录这个线程ID （偏向锁）

如果线程争用：升级为 自旋锁

10次以后，

升级为重量级锁 - OS

 

执行时间短（加锁代码），线程数少，用自旋

执行时间长，线程数多，用系统锁

 

atomic lock都是自旋锁

 

synchronized（object）不能使用String常量、Integer、Long

 

 

 

 

## **volatile**

***\*问：到底是强制读主线程的，还是写入时间不定\****

保证线程可见性

——MESI

——缓存一致性协议

禁止指令重排序（cpu指令重排、汇编重排；禁止的语言级的；读写屏障）

 

双重检查锁的单例加volatile，指令重排

 

JVM new对象过程：

1、申请内存，给成员变量默认值

2、给成员变量赋值

3、把值给对象

指令重排后2、3步骤会调换

 

锁优化：

粒度减小

粒度加大的情况：细锁多



锁定某对象o,如果o的属性发送改变，不影响锁的使用

但是如果o变成另一个对象，则锁定的对象发生改变

应该避免将锁定对象的引用变成另外的对象

加 final

 

 

## ***\*CAS\****（无锁优化）

Compare And Set

 

AtomicStampedReference利用版本号解决ABA问题

 

 

## **Atomic**

多个线程对一个数进行递增，那种效率更高？synchronized、AtomicLong、LongAdder

 

LongAdder：分段锁 + CAS；专门用来做多个线程对一个数进行递增。

一个数分开，装到数组里面。

 

 

## **ReentrantLock**

1、在写代码的时候必须用try、finally包裹lock()、unlock()，防止程序发生异常没有解锁

2、可以替代synchronized，但比synchronized好用，可以使用tryLock指定时间内获得锁，超时就不阻塞，直接放弃获得锁

3、lockInterruptibly()：