# Java基础

面向对象特点，设计原则

## 1、集合

### hashmap

结构：数组+链表+红黑树

链表转为红黑树的条件：链表长度8、整体长度到达64

链表变成红黑树的条件

尾插法

### ConcurrentHashMap

## 2、jdk8新特性

lamada表达式

stream流：filter、orelse、andany、skip

## 3、JVM

内存分布

垃圾回收机制

类加载机制：加载、验证、准备、解析、初始化	 	静态代码块什么时候加载

## 4、多线程

线程的5个状态：新建，就绪，执行，阻塞，死亡

sleep：阻塞

wait：等待阻塞——阻塞的一种

多线程、锁



异常

反射

Final的string在内存那一块

String的equals如何实现的

定时任务：Timer


​	创建对象的几种方式：
​		new
​		clone()
​		反序列化
​		反射：newInstance()

assert 断言

迭代器iterator

守护线程

Object的方法

private protected private default区别	

多线程：pong()

# 基础

tcp/ip3次握手

手写单例模式

基本的数据结构

基本的排序方法

深度优先算法

判断一个数是否为2的n次方：位运算 n&(n-1) = 0

http和https的区别

IO:NIO BIO AIO

xss攻击	

# 框架

## 	spring

AOP原理

IOC

设计模式：工厂模式，单例模式、原型模式

bean生命周期、作用域

bean线程安全不

bean的创建过程

@transaction失效的情况

异步调用注解@Async

spring beans

事务传播		
	

## springMVC

流程

## springboot

自动装配原理

启动流程

## mybatis

mybatis缓存

mybatis和spring整合，一级缓存失效的原因

Mybatis缓存实现原理

mybatis-plus

## springCloud

consoul(CP)、zookeeper（CP）、eureka（AP）的却别：CAP理论

Fenig consuol实现原理

# redis

持久化类型

数据类型

缓存穿透、雪崩、预热、更新、降级

主从模式（主从复制原理）

集群原理

一致性hash算法

redis分布式锁使用的命令

​	setnx  +   expire:set key value ex 100 nx

淘汰策略（回收策略）：LRU

set和sortedset的区别

哨兵机制

# mysql

范式

锁

ACID(原子性、一致性、隔离性、持久性)

事物的隔离级别（读未提交、读已提交（默认）、可重复读、可序列化读）

脏读、幻读、不可重复读

存储引擎

索引：b+树

sql优化

主键索引和xxx索引的区别

mvcc实现原理

预编译原理



# **数据库**

## 1、**范式**

（1）第一范式：属性不可再分

（2）第二范式：消除了非主属性对于码的部分函数依赖

（3）第三范式：消除了非主属性对于码的传递依赖

（4）BC范式：消除了主属性对于码的部分传递依赖

***\*概念：\****

函数依赖：x->y，即根据x可以推倒出y，如id->name，则name函数依赖于id

完全函数依赖：x->y，如（学号，课程号）->成绩，单个学号或课程号不能推出成绩，则称				成绩完全函数依赖于（学号，课程号）

部分函数依赖：依旧如上例子，如果学号或者课程号单独一个可以推出成绩，则称成绩部分函数依赖于（学号，课程号）

码：也成“键”或“键码”。指主码或候选码

超码：y部分依赖于x，则称x为超码

候选码：y完全依赖于x，则称x为候选码

主码：如果候选码多于一个，就选其中一个为主码（主键）

全码：在最坏情况下，整个属性全是码，称全码

外码：即外键

主属性：构成码的属性；如果码是（id,name）；那么id,name都是主属性

非主属性：不是主属性的都是非主属性

 

## 2、**事务的4个特性（ACID）**

\1) 原子性（atomicity）：要么全部执行，要么全部不执行。

\2) 一致性（consistency）：事务在完成时，必须是所有的数据都保持一致状态。（实例：转账，两个账户余额相加，值不变。）

\3) 隔离性（isolation）：一个事务的执行不能被其他事务所影响。

\4) 持久性（durability）：一个事务一旦提交，事物的操作便永久性的保存在DB中。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

 

脏读、不可重复读、幻读

 

事务的隔离级别

① Serializable（串行化）

② Repeatable read（可重复读，默认级别）

③ Read committed (读已提交)

④ Read uncommitted (读未提交)

<img src="img\1.jpg" />

 

 

## **3、数据库索引 B+树**







# 消息队列

​	类型
​		点对点
​		一对多（一个生产者，多个消费者）
​		广播（交换机把消息广播给所有绑定的队列，每个消费者绑定一个队列，实现重复消费，每个消费者可以不一样的逻辑）
​		不同的消息发给不同的消费者（通过一个key,key也可以使用通配符）
​		

使用场景
	流量削峰
	应用解耦
	
消息重复消费
	自动确认
	手动确认

# Nginx

​	配置文件分模块

# linux

​	top
​	free
​	ps -ef



# 其他



分布式事务


项目的难点和技术亮点
Dubbo的rpc的底层原理
加密算法

线程死锁的条件
线程池的调度





1、线程和进程：

进程：资源分配的单位

线程：调度和执行的单位

2、new一个对象执行代码顺序

（1）静态变量赋初值

（2）父类代码块，子类静态代码块

（3）父类代码块，父类构造方法

（4）子类代码块，子类构造方法

 

3、StringBuffer和StringBuilder的区别？

StringBuffer是线程安全的，StringBuilder是线程不安全的。

StringBuffer就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类

 

4、String 类为什么被设计为final？

（1）设计安全：String有的方法native的，也就是使用本地的操作系统的api，不能被继承就不能改变重写其中的方法

（2）实现常量池，节约了heap空间

（3）为了线程安全

（4）因为不可变，创建String的时候就缓存好了hashCode的值，不用重新计hashCade，这也是为什么String作为hashMap的key比其他对象更快的原因。

 

5、HashTable和HashMap的区别

底层存储结构和解决冲突的方法都是一样的，

HashTable是线程安全的，HashMap是线程不安全的；

HashTable的默认容量为11，而HashMap为16；

Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。

Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。

Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时。

 

6、HashMap原理

底层是数组和链表实现的hash表，在jdk1.8版本后，java对HashMap做了改进，在链表长度大于8的时候，将后面的数据存在红黑树中，以加快检索速度。

 

7、既然红黑树好，为什么不直接使用红黑树？

因为链表虽然查询慢，但是增加和删除比较快，红黑树虽然查询比链表快，但是插入和删除就比链表慢了，比如插入就要左旋右旋。

如果元素小于8个，查询成本高，新增成本低

如果元素大于8个，查询成本低，新增成本高

 

8、Java中还有哪些集合用到了红黑树

TreeMap、HashMap、

 

9、红黑树的时间复杂度：O(logn)

 

10、java中的事务

Java事务的类型有三种：JDBC事务、JTA（Java Transaction API）事务、容器事务。

 

Object中的方法

native关键字

hashcode和equals

haspMap 

NIO

JAT事务

线程池

同时执行完5个线程后再执行主线程的方法

请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处

 

实现set接口的有哪些类?

你是如何理解Java里面的垃圾收集机制(最好分析到对象在堆中的分配上)

你对Spring的理解，Spring里面的代理是怎么实现的，如果让你设计，你怎么设计





# 项目经验

## 易空运

业务逻辑

​	航班生成：自动、手动

​	查航班，三天的，价格最便宜的放最上面

​		这里涉及到合伙人下级的价格

​	具体选择：货物类型、回单类型、货代还是货站、保价，代提，自提，

​	代提：放到货站，选择班车专车，选择车型，班车专车计价方式不同







下单

​	更新可用仓位

​	计价、自动扣款，余额不足，添加定时任务，取消订单



发货：多退少补，散单应收



​	合伙人分红：航班加价

​	航班价格、最低价格，区间价格

​	货物类型

​	回单类型

​	班车专车计价







幂等性问题：
	事务  +   update 订单状态 where 订单状态 = 已揽收



锁等待时间过长报错的情况

## 递四方

快速试单：

​	客户信息

​	



# 面试题

1、final、finally、finalize的却别

2、泛型的原理：设置为Object，然后强转

3、finally中的return先执行还是try中的return先执行？

4、用spring集合自己写的框架

5、DCL中要不要使用volatile关键字？为什么？

双重检测锁中使用volatile的作用：防止指令重拍；如果指令重排存在，一个线程给对象赋默认值后，第二个线程可能读到还未赋初值的对象。





别人的**滴滴一面**：

讲一下快速排序，经典快排存在的问题

1000万个取其中最大的100个数

1 MapReduce的设计思想，但是有内排序的问题

2堆排序，堆排序的过程

树的中序遍历实现

递归

借助栈

介绍下osi7层模型

arp协议缓存的过程

TCP的控制位

TCP的状态

TCP建连的状态

TCP的头部信息

jvm监控系统是通过jmx做的吗？再改进中，用jdk自带的工具

Java内存结构

jvm的栈跟线程关系

是每个线程都会创建一个栈还是共用一个栈

介绍volatile的功能

总线锁的副作用

内存屏障的汇编指令是啥？

你有看过源码嘛？AQS

介绍一下AQS

扯到了CAS的原理

AQS怎么阻塞当前线程

locksupport的park在jvm怎么实现的？

你了解垃圾回收吗？

垃圾回收器让工作线程停顿下来是怎么做的？

GC Roots对象有几种？

gc roots怎么判断一个对象没有被引用

**滴滴二面**

介绍项目

spark用的多吗？

在Java开发平时做了啥东西？

看过开源吗？看过 JDK spring的吗

介绍下concurrentHashMap

介绍下CAS

介绍下volatile

算法题讲解其思路

手写生产者和消费者

mysql索引失效与优化的问题

mysql的索引结构

回表操作分析

介绍下左连接、右连接、全连接查询

redis用的多吗

redis是单线程还是多线程

为什么单线程跑的快

redis存在线程安全的问题吗？为什么？

spring用的比较多吗？

spring aop怎么使用以及其原理？

怎么实现远程rpc?扯到了netty

es用过吗？稍微了解下，用的不多，检索快

服务被比人攻击，不断刷新页面，怎么解决这个问题

反问面试官怎么处理高并发，面试官说了redis、es，我补充看到过lvs nginx cdn







没接触过直接说没接触过

面试要积极表现自己的”表达“